<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8"><link rel="stylesheet" href="../Assets/css/mdf.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/highlight.js/9.9.0/styles/xcode.min.css"><title>02-02</title></head><body>

<article id="mdf">
    <h1>Работа с типами данных. Псевдонимы типов</h1>
    <p>Поздравляю тебя, мы переходим к более интересным темам в программировании. Сегодня ты изучишь разные операции с типами данных, приведение одного типа к другому, а также выучишь такие конструкции, как псевдонимы типов.</p>
    <p>В прошлом конспекте мы рассмотрели фундаментальные типы данных в языке Swift. Пришло время посмотреть что можно делать с этими типами данных.</p>
    
    <h2>Операции с числовыми типами</h2>
    <h3>Арифметические операторы</h3>
    <p>Ниже список доступных арифметических операций, которыми можно пользоваться в Swift'e:</p>
    <p><strong><em>Оператор сложения</em></strong> <code>+</code> &mdash; используется для сложения двух операндов, например, <code>a+b</code>. Тип результата будет равен типу операндов.</p>
    <p><strong><em>Оператор вычитания</em></strong> <code>-</code> &mdash; здесь все интереснее, минус может использоваться как для вычитания одного операнда из другого <code>a-b</code>, так и для того, чтобы сделать отрицательный операнд <code>-a</code>. Тип результата также соответствует типам операндов.</p>
    <p><strong><em>Оператор умножение</em></strong> <code>*</code> &mdash; перемножает два операнда <code>a*b</code> и возвращает значение с типом, равным двум операндам.</p>
    <p><strong><em>Оператор деления</em></strong> <code>/</code> &mdash; делит первый операнд на второй <code>a/b</code> и возвращает значение с типом, соответствующим этим двум операндам.</p>
    <p>С этим, думаю, не должно быть сложностей, все как в математике в школе)))</p>
    <p>Раньше были операторы инкремента <code>++</code> и декремента <code>--</code>, но разработчики свифта решили это упразднить и убрали такие операторы. Сейчас для инкремента и декремента используются <code>+1</code> или <code>-1</code> ...странное решение, но не нам осуждать эппл:)</p>
    <p>Перечисленные операторы можно использовать для проведения математических операций в программировании. Например:</p>
    <figure class="mdf-code c1">
        <img style="max-height: 200px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-01.png" alt="">
        <figcaption>Пример использования арифметических операций для типа Int</figcaption>
    </figure>
    <p>Если с операциями сложения, вычитания и умножения тут все понятно. То с делением не все так просто. При обычном операторе деления отбрасывается остаток, то есть в нашем случае если поделить <code>42</code> на <code>23</code>, то будет только одно целое деление. Так как мы используем тип <code>Int</code>, то у <code>od</code> результат будет также целочисленным, поэтому и отброшен остаток. Если изменить тип на <code>Double</code>, то значения изменятся:</p>
    <figure class="mdf-code c1">
        <img style="max-height: 200px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-02.png" alt="">
        <figcaption>Пример использования арифметических операций для типа Double</figcaption>
    </figure>
    <p>С типом <code>Double</code> дробная часть осталась на месте.</p>
    <p>Напомню, что все операции между константами или переменными можно проводить только в том случае, если они будут одного типа.</p>
    <p>Также есть операция вычисления остатка от деления. В процессе вычисления остатка от деления нужно учитывать то, что знак у результата будет такой же, какой был у делимого операнда. То есть, например, ты делишь <code>-a</code> на <code>b</code> тогда остаток от деления будет отрицательным:</p>
    <figure class="mdf-code c1"><img style="max-height: 150px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-03.png" alt=""></figure>
    <p>Рассмотрим пример выше. Для вычисления остатка от деления у чисел с плавающей точкой в Swift есть функция</p>
    <pre><code class="hljs">truncatingRemainder(dividingBy: )</code></pre>
    <p>Она должна вызываться у первого операнда (делимого), а параметром для этой функции будет служить второй операнд (делитель). Вызываются методы и свойства у переменных и констант через точку (см пример выше).</p>
    <p>Для целых чисел есть специальный символ &mdash; <code>%</code>. Он также вернет остаток от деления.</p>

    <h3>Приведение числовых типов</h3>
    <p>Как мы уже сказали в Swift есть оператор, позволяющий вычислить остаток после деления. Иногда это называют остаток от деления, но если вы хотите быть более конкретным, это не одно и то же.</p>
    <p>Давайте посмотрим, почему этот оператор полезен. Если бы я сказал вам, что до особого события осталось 465 дней, как бы вы могли передать эту информацию пользователю более ясно?</p>
    <p>Вы можете начать с такого кода:</p>
    <figure class="mdf-code c1"><img style="max-height: 90px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-04.png" alt=""></figure>
    <p>Это напечатает, что до события осталось 66 недель, но это не совсем так. Столкнувшись с двумя такими целыми числами, Swift разделит их и округлит до нуля, чтобы получить целое число. <code>465</code> разделенное на <code>7</code> не равно <code>66</code>, поэтому это сообщение будет не совсем точное.</p>
    <p>Мы можем использовать <code>Double</code>, а не <code>Int</code>, поэтому мы получим более точный ответ.</p>
    <p>Но теперь мы получаем кое-что технически правильное: До мероприятия осталось <code>66.42857142857143</code> недели. Но согласитесь, это не то что нам нужно</p>
    <p>Вот где нужен оператор остатка:</p>
    <figure class="mdf-code c1"><img style="max-height: 90px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-05.png" alt=""></figure>
    <p>Таким образом, <code>weeks</code> делит <code>465</code> на <code>7</code> и округляется до <code>0</code>, что дает <code>66</code> недель, затем <code>days</code> использует оператор остатка, чтобы вычислить, остаток.</p>
    <p>Оператор остатка действительно полезен и часто встречается.</p>
    <p><strong><em>Совет:</em></strong> если ваша цель &mdash; узнать, делится ли это число поровну на другое число, то у Swift есть более простой подход:</p>
    <figure class="mdf-code c1"><img style="max-height: 80px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-06.png" alt=""></figure>
    <p>В предыдущей части я говорил, что при выполнении операций обе переменные или константы должны иметь один тип. А что если вам нужно сложить, например, <code>Int</code> и <code>Double</code>?</p>
    <p>В такой ситуации нужно определиться, нужна ли вам дробная часть. Если дробная часть нужна, тогда мы приводим оба операнда к типу <code>Double</code>, если дробная часть неважна, тогда к <code>Int</code>.</p>
    <p>Приведение типов в свифте происходит следующим образом:</p>
    <figure class="mdf-code c1"><img style="max-height: 240px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-07.png" alt=""></figure>
    <p>Если при выполнении операции не привести все операнды к одному типу, то Xcode выдаст ошибку:</p>
    <figure class="mdf-code c1"><img style="max-height: 45px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-08.png" alt=""></figure>
    <div class="mdf-notice">
        <p><strong>Важно:</strong> стоит отметить, что все методы приведения являются глобальными, то есть они доступны из любой точки программы. Раньше мы говорили о том, что все типы данных &mdash; это объекты. У объектов есть запрограммированные методы и свойства (с этими понятиями мы подробнее разберемся чуть позже). Методы приведения, которые мы использовали в предыдущем примере является методом инициализатором. Метод инициализатор имеет свое собственное имя &mdash; <code>init()</code> и его вызов выглядит следующим образом:</p>
    </div>
    <pre><code class="hljs">ИмяТипаДанных.<span class="hljs-keyword">init</span>()</code></pre>
    <p>В результате выполнения этого метода будет создан новый объект, соответствующий типу данных (строка, число и тп). В Swift вызовы методов инициализаторов являются упрощенными и позволяют не писать <code>init</code>:</p>
    <pre><code class="hljs">ИмяТипаДанных()</code></pre>
    <p>В результате выполнения будет тоже самое, что и в примере выше.</p>
    <p>В примере с приведением типов я привел следующие конструкции:</p>
    <p><code>Double(...)</code> &mdash; для приведения к типу <code>Double</code></p>
    <p><code>Float(...)</code> &mdash; для приведения к типу <code>Float</code></p>
    <p><code>Int(...)</code> &mdash; для приведения к типу <code>Int</code>.</p>
    <p>Рассмотрим, чем отличается приведение типов на практике:</p>
    <figure class="mdf-code c1"><img style="max-height: 110px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-09.png" alt=""></figure>
    <p>Из результатов выполнения видно, что при перемножении чисел с типом <code>Double</code> точность результата выше, чем у перемножения интов.</p>
    <p><strong><em>Рекомендация:</em></strong> если в конечном итоге тебе нужно получить целое число, то советую вначале все операнды привести к <span>Double</span>, выполнить операцию, а конечный результат перевести в <span>Int</span>. Например:</p>
    <figure class="mdf-code c1"><img style="max-height: 220px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-10.png" alt=""></figure>
    <p>На примере выше я показал как можно выйти из этой ситуации. Либо сначала провести операцию, а затем привести к целому числу, либо объединить все операции в одну строку. И так, и так можно делать на практике)))</p>
    
    <h3>Составные операторы</h3>
    <p>Кроме операторов <code>+</code>, <code>-</code>, <code>*</code> и <code>/</code> есть еще так называемые &mdash; <em>составные операторы</em>.</p>
    <p><em>Составной оператор</em> &mdash; оператор, который позволяет выполнить операцию над операндами, а затем сразу же присвоить значение. То есть, по сути это совмещенный арифметический оператор <code>+</code>, <code>-</code>, <code>*</code> и <code>/</code> вместе с оператором присваивания <code>=</code>. Рассмотрим пример ниже:</p>
    <figure class="mdf-code c1"><img style="max-height: 440px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-11.png" alt=""></figure>
    <blockquote class="mdf-task">
        <p>Повтори все предыдущие операции на разных числовых типах. Понаблюдай за их поведением. Какие особенности выявил? Запиши их к себе в конспект:)</p>
    </blockquote>
    <p>Ранее я говорил про операции инкремента и декремента, в текущей версии Swift они выглядят следующим образом:</p>
    <figure class="mdf-code c1"><img style="max-height: 120px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-12.png" alt=""></figure>
    <p>Что соответствует операциям:</p>
    <pre><code class="hljs">someValue = someValue + <span class="hljs-number">1</span>
someValue = someValue - <span class="hljs-number">1</span></code></pre>
    <p>Больше заданий с числами будет завтра в домашнем задании. Сегодня проработай существующие примеры на разных числовых типах данных.</p>
    
    <h2>Операции со строковыми типами</h2>
    <h3>Приведение строковых типов</h3>
    <p>Как и числовые типы, строковые тоже можно приводить друг к другу, а также любой другой тип можно привести к строковому типу. В Swift, также как и у числовых типов, у строки есть метод инициализации:</p>
    <pre><code class="hljs"><span class="hljs-type">String</span>(<span class="hljs-number">_</span>:)</code></pre>
    <p>В этот метод можно передать значение с произвольным базовым типом и оно преобразуется в строку:</p>
    <figure class="mdf-code c1"><img style="max-height: 150px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-13.png" alt=""></figure>
    <p>Также можно преобразовать из строки в числовой тип. Но там значение будет опционального типа, с ними мы познакомимся немного позже.</p>
    <p>Естественно, каждое значение с типом <code>Character</code> можно привести к типу <code>String</code>:</p>
    <pre><code class="hljs"><span class="hljs-type">String</span>(<span class="hljs-type">Character</span>(<span class="hljs-string">"a"</span>))</code></pre>
    <p>Но не каждую строку можно преобразовать из <code>String</code> в <code>Character</code>:</p>
    <pre><code class="hljs"><span class="hljs-type">Character</span>(<span class="hljs-type">String</span>(<span class="hljs-string">"a"</span>))      <span class="hljs-comment">// эта строка приведется без всяких ошибок</span>
<span class="hljs-type">Character</span>(<span class="hljs-type">String</span>(<span class="hljs-string">"Hello!"</span>)) <span class="hljs-comment">// при попытке привести эту строку возникнет ошибка</span></code></pre>

    <h3>Объединение строк</h3>
    <p>Возможно, вы были знакомы с интерполяцией строк из курса информатики. Вообще, существует два механизма объединения строк: <strong><em>интерполяция</em></strong> и <strong><em>конкатенация</em></strong>. Оба эти механизма предназначены для объединения строк в одну более длинную. Рассмотрим объединение строк в Swift.</p>
    <p><strong><em>Интерполяция</em></strong> &mdash; механизм, позволяющий объединять строковые литералы, переменные, константы и выражения в едином строковом литерале:</p>
    <pre><code class="hljs"><span class="hljs-keyword">let</span> name = <span class="hljs-string">"Никита"</span>
<span class="hljs-comment">/// Интерполяция производится при помощи конструкции \()</span>
<span class="hljs-keyword">let</span> hello = <span class="hljs-string">"Привет, меня зовут</span> \(name)<span class="hljs-string">"</span>
<span class="hljs-keyword">let</span> myHeightInMeters = <span class="hljs-number">1.9</span>
<span class="hljs-keyword">let</span> infoAboutMyHeight = <span class="hljs-string">"Мой рост</span> \(myHeightInMeters * <span class="hljs-number">100</span>) <span class="hljs-string">сантиметров"</span></code></pre>
    <p>Из примера видно, что при интерполяции в конструкции <code>\(...)</code> можно использовать выражения.</p>
    <p><strong><em>Конкатенация</em></strong> &mdash; объединение строк при помощи операции сложения <code>+</code>:</p>
    <pre><code class="hljs"><span class="hljs-keyword">let</span> weight = <span class="hljs-number">98</span>
<span class="hljs-keyword">let</span> metric = <span class="hljs-string">"килограммов"</span>
<span class="hljs-keyword">let</span> text = <span class="hljs-string">"Мой вес: "</span> + <span class="hljs-type">String</span>(weight) + metric</code></pre>
    <p>В примере используется механизм конкатенации. Значение <code>weight</code> не строкового типа, поэтому для преобразования его в строку используется <code>String(weight)</code>.</p>
    <p>Значения <code>Character</code> при конкатенации также должны быть преобразованы в строку.</p>

    <h2>Операции над логическим типом</h2>
    <h3>Логические операторы</h3>
    <p>Логические операторы проверяют на истинность какое-либо утверждение. В Swift существует три стандартных логических оператора:</p>
    <ul>
        <li>Логическое НЕ <code>!a</code></li>
        <li>Логическое ИЛИ <code>a || b</code></li>
        <li>Логическое И <code>a && b</code></li>
    </ul>
    <p>Если с оператором <em>логического НЕ</em> более менее ясно, он является унарным и возвращает инвертированное логическое значение (напр: было <code>true</code>, а с <em>логическим НЕ</em> стало <code>false</code>, и наоборот). <em>Логическое НЕ</em> это префиксный оператор, поэтому восклицательный знак записывается перед операндом. Выражение <code>!а</code> можно прочитать как "не а".</p>
    <pre><code class="hljs"><span class="hljs-keyword">var</span> value = <span class="hljs-literal">true</span> <span class="hljs-comment">// true</span>
!value <span class="hljs-comment">// false</span></code></pre>
    <p>С операторами <em>логического И</em> и <em>ИЛИ</em> все немного сложнее.</p>
    <p>Оператор <em>логического И</em> <code>&&</code> вернет <code>false</code>, если хотя бы один из операндов равен <code>false</code>. В остальных случаях он вернет <code>true</code>.</p>
    <p>Оператор <em>логического ИЛИ</em> <code>||</code> вернет <code>false</code>, если все операнды равны <code>false</code>. Во всех остальных случаях вернет <code>true</code>.</p>
    <p>Рассмотрим это на практике:</p>
    <figure class="mdf-code c1"><img style="max-height: 600px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-14.png" alt=""></figure>
    <p>В комментариях к коду я постарался описать происходящее, особенно в последних четырех примерах. Моя рекомендация: в реальной работе никогда не сравнивай логическими операторами три операнда, можно легко запутаться. Проще разбить это на несколько шагов.</p>
    <p>Но чтобы было проще прочитать этот пример, то усвой одно правило:</p>
    <blockquote class="mdf-important no-title">
        <p>Программа выполняется сверху вниз и слева направо</p>
    </blockquote>
    <p>Поэтому стоит читать код именно так, как ты читаешь любой другой текст:)</p>
    <p>В Swift если тебе нужно выполнить какое-то выражение вперед другого, то используются скобки (также как в математике).</p>

    <blockquote class="mdf-task">
        <p>Остановись на этой теме подольше. Попробуй прогнать через логические операторы разное количество операндов с разными значениями, чтобы лучше усвоить механизм.</p>
    </blockquote>

    <h3>Операторы сравнения</h3>
    <p>За кулисами Swift реализует сравнения удивительно умным способом, который фактически позволяет сравнивать самые разные вещи. Например, в Swift есть специальный тип для хранения дат, который называется <code>Date</code>, и вы можете сравнивать даты, используя те же операторы: например, <code>someDate &lt; someOtherDate</code>.</p>
    <p>Начиная с Swift 5.3 и новее, мы можем даже попросить Swift сделать наши перечисления сопоставимыми, например:</p>
    <figure class="mdf-code c1"><img style="max-height: 210px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-15.png" alt=""></figure>
    <p>Этот код напечатает <code>&laquo;true&raquo;</code>, потому что <code>small</code> стоит перед <code>large</code> в списке кейсов перечисления.</p>
    <p>В Swift есть 6 операторов сравнения:</p>
    <ul>
        <li><strong><em>Оператор "равенства"</em></strong> <code>==</code> проверяет операнды на равенства друг другу и <em>возвращает</em> <code>true</code> <em>если операнды равны</em>.</li>
        <li><strong><em>Оператор "неравенства"</em></strong> <code>!=</code> проверяет операнды на неравенства друг другу и <em>возвращает</em> <code>true</code> <em>если операнды не равны</em>.</li>
        <li><strong><em>Оператор "больше"</em></strong> <code>&gt;</code> если первый операнд <em>больше</em> второго, тогда <em>вернет</em> <code>true</code>.</li>
        <li><strong><em>Оператор "меньше"</em></strong> <code>&lt;</code> если первый операнд <em>меньше</em> второго, тогда <em>вернет</em> <code>true</code>.</li>
        <li><strong><em>Оператор "больше либо равно"</em></strong> <code>&gt;=</code> если первый операнд <em>больше</em> второго <em>или равен</em> ему, то <em>вернется</em> <code>true</code>.</li>
        <li><strong><em>Оператор "меньше либо равно"</em></strong> <code>&lt;=</code> если первый операнд <em>меньше</em> второго <em>или равен</em> ему, то <em>вернется</em> <code>true</code>.</li>
    </ul>
    <figure class="mdf-code c1"><img style="max-height: 130px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-16.png" alt=""></figure>

    <h3>Операторы диапазона</h3>
    <p>В Swift есть также операторы, которые позволяют объединить несколько значений, например, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code> то есть от 1 до 6. Эти операторы называются <em>операторами диапазона.</em></p>
    <p>Есть два таких оператора:</p>
    <ul>
        <li><p><em>Закрытый оператор</em> <code>a...b</code> это такой оператор, который объединяет все значения от <code>a</code> до <code>b</code>.</p>
            <p>Например:</p>
            <figure class="mdf-code c1"><img style="max-height: 110px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-17.png" alt=""></figure>
        </li>
        <li><p><em>Полуоткрытый</em> <code>a..&lt;b</code> &mdash; объединит все значения, кроме последнего.</p>
            <p>Например:</p>
            <figure class="mdf-code c1"><img style="max-height: 110px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-18.png" alt=""></figure>
        </li>
    </ul>
    <p>Также еще существует <em>односторонний оператор</em>. Он используется в том случае, когда диапазон ограничен только с одной стороны. В практике я такого не видел)) Но пишутся они вот так:</p>
    <pre><code class="hljs">a..
a&gt;..
..</code></pre>
    <p>В будущем мы поработаем с этими операторами побольше. Сейчас просто рассмотри примеры и попробуй вывести некоторые диапазоны, чтобы понять принцип работы механизмов.</p>
    
    <h2>Псевдонимы типов</h2>
    <p>В Swift есть магическая штука &mdash; <strong><em>псевдонимы типов</em></strong>. Псевдоним типа дает возможность создать дополнительное имя для любого типа данных, чтобы в будущем обращаться к нему по новому имени. Этот механизм придуман для того, когда неудобно использовать существующее имя в контексте программы, например, если используешь <code>UInt</code> для определения возраста.</p>
    <p>Для того чтобы задать псевдоним имени существует команда <code>typealias</code>:</p>
    <figure class="mdf-code c1"><img style="max-height: 60px;" src="https://raw.githubusercontent.com/nskazakov/Attributes/master/Assets/images/02%20Базовые%20конструкции%20Swift/02-02%20Работа%20с%20типами%20данных/02-02-19.png" alt=""></figure>
    <p>В будущем при разработке у тебя возможно будут более неудобные типы, нежели <code>UInt</code> для определения возраста))) Например, тип может состоять из нескольких слов и иметь большую длину, поэтому проще и красивее заменить его псевдонимом.</p>
    <p>У любого типа может быть произвольное количество псевдонимов и все они могут участвовать в выполнении программы.</p>
    <p>При использовании псевдонима типа все свойства и методы основного типа сохраняются:)</p>
    <p>Все псевдонимы вместе с оригинальным названием типа можно использовать в программе. То есть каждый из псевдонимов наравне с основным типом может быть использован для объявления параметров.</p>
    <p>Созданный псевдоним наделяет параметры теми же возможностями, что и родительский тип данных. Однажды объявив его, вы сможете использовать данный псевдоним для доступа к свойствам и методам типа.</p>
    <p>Для Swift обращение к псевдониму равносильно обращению к самому типу данных. Псевдоним &mdash; это ссылка на тип. Запомните, что псевдонимы можно использовать для совершенно любых типов.</p>
    <blockquote class="mdf-task">
        <p><strong>Немного поработаем:</strong></p>
        <ol class="numeric">
            <li>Создай несколько псевдонимов одинакового типа</li>
            <li>Создай константы с типом каждого из созданных псевдонимов</li>
            <li>Проведи над ними изученные операции</li>
            <li>Попробуй вызвать у созданных констант свойства</li>
            <li>Выведи все результаты в консоль</li>
        </ol>
    </blockquote>
    <p>Сейчас, возможно, ты не до конца понял, для чего использовать эти псевдонимы, но в будущем, когда мы будем изучать кортежи, ты поймешь:)</p>
    <p class="mdf-callto mdf-next">На этом мы завершаем изучение базовых возможностей языка. Дальше будет много интересного и мы будем очень много применять изученные в эти дни материалы. Поэтому перечитай конспекты еще раз, перед и в процессе выполнения завтрашнего домашнего задания.</p>

    <div class="mdf-addons">
        <h2>Дополнительные материалы</h2>
        <ul>
            <li><a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html" target="_blank">Basic Operators</a></li>
        </ul>
    </div>
</article>

</body>
</html>